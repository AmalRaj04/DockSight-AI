"""Tool for composing scientific reports."""

import os


class ReportWriter:
    """Composes structured scientific reports from analysis results."""

    def __init__(self, groq_api_key=None):
        self.groq_api_key = groq_api_key or os.getenv("GROQ_API_KEY")
        self.groq_client = None
        
        if self.groq_api_key:
            try:
                from groq import Groq
                self.groq_client = Groq(api_key=self.groq_api_key)
            except ImportError:
                print("Warning: groq package not installed. Install with: pip install groq")
            except Exception as e:
                print(f"Warning: Failed to initialize Groq client: {e}")

    def compose_report(self, analysis_data):
        """Compose complete scientific report."""
        report_sections = []

        # Build report sections
        report_sections.append(self._generate_header(analysis_data))
        report_sections.append(self._generate_introduction())
        report_sections.append(self.generate_methods_section(analysis_data.get("metadata", {})))
        report_sections.append(self.generate_results_section(analysis_data))
        
        # Use Groq for discussion if available
        if self.groq_client:
            discussion = self._generate_discussion_with_llm(analysis_data)
        else:
            discussion = self.generate_discussion_section(analysis_data)
        
        report_sections.append(discussion)
        report_sections.append(self.add_scientific_disclaimer())

        return "\n\n".join(report_sections)

    def _generate_discussion_with_llm(self, analysis_data):
        """Generate discussion section using Groq LLM."""
        ranked_ligands = analysis_data.get("ranked_ligands", [])
        
        if not ranked_ligands:
            return self.generate_discussion_section(analysis_data)
        
        # Prepare structured input for LLM
        prompt = self._build_discussion_prompt(analysis_data)
        
        try:
            response = self.groq_client.chat.completions.create(
                model="llama-3.3-70b-versatile",  # Updated to current model
                messages=[
                    {
                        "role": "system",
                        "content": "You are a scientific writing assistant for molecular docking analysis. Generate clear, accurate, and scientifically responsible discussion text. Use conservative language and emphasize limitations. Do NOT invent data or make efficacy claims."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.2,
                max_tokens=2000,
            )
            
            llm_discussion = response.choices[0].message.content
            
            # Ensure discussion section has proper header
            if not llm_discussion.startswith("## Discussion"):
                llm_discussion = "## Discussion\n\n" + llm_discussion
            
            return llm_discussion
            
        except Exception as e:
            print(f"Warning: Groq LLM failed, using fallback: {e}")
            return self.generate_discussion_section(analysis_data)

    def _build_discussion_prompt(self, analysis_data):
        """Build structured prompt for LLM discussion generation."""
        ranked_ligands = analysis_data.get("ranked_ligands", [])
        interactions = analysis_data.get("interactions", {})
        
        prompt = "Generate a scientific discussion section for a molecular docking analysis report.\n\n"
        prompt += "**Ranked Ligands (by binding affinity):**\n"
        
        for idx, ligand in enumerate(ranked_ligands[:5], 1):  # Top 5 only
            prompt += f"{idx}. {ligand['ligand_name']}: {ligand['binding_affinity']} kcal/mol\n"
        
        if interactions:
            prompt += "\n**Interaction Data Available:** Yes\n"
        
        prompt += "\n**Requirements:**\n"
        prompt += "- Interpret the binding affinity results\n"
        prompt += "- Discuss the top-ranked ligand\n"
        prompt += "- Mention structure-activity relationships if multiple ligands present\n"
        prompt += "- Include a 'Limitations' subsection discussing:\n"
        prompt += "  * Computational prediction limitations\n"
        prompt += "  * Need for experimental validation\n"
        prompt += "  * Protein flexibility and solvent approximations\n"
        prompt += "- Use conservative, qualified language (e.g., 'suggests', 'may indicate')\n"
        prompt += "- Do NOT make drug efficacy or safety claims\n"
        prompt += "- Keep discussion concise (3-4 paragraphs)\n"
        
        return prompt

    def _generate_header(self, analysis_data):
        """Generate report header."""
        return "# Molecular Docking Analysis Report\n\n**Generated by DockSight AI**"

    def _generate_introduction(self):
        """Generate introduction section."""
        intro = "## Introduction\n\n"
        intro += "This report presents the results of a molecular docking analysis performed using AutoDock Vina. "
        intro += "The analysis evaluates binding affinity predictions for a set of ligands against a target protein. "
        intro += "Results are ranked by predicted binding energy (ΔG) to identify the most promising candidates for further investigation."
        return intro

    def generate_executive_summary(self, ranked_ligands):
        """Generate executive summary section."""
        if not ranked_ligands:
            return "**Summary:** No ligands were successfully ranked."

        best = ranked_ligands[0]
        summary = f"**Summary:** {len(ranked_ligands)} ligands were analyzed. "
        summary += f"The top-ranked ligand is **{best['ligand_name']}** "
        summary += f"with a predicted binding affinity of **{best['binding_affinity']} kcal/mol**."
        return summary

    def generate_methods_section(self, analysis_metadata):
        """Generate methods and parameters section."""
        methods = "## Methods\n\n"
        methods += "### Docking Protocol\n\n"
        methods += "Molecular docking was performed using AutoDock Vina. "
        methods += "Binding affinities (ΔG) were calculated for each ligand-protein complex. "
        methods += "Multiple poses were generated per ligand, and the pose with the lowest binding energy was selected as the best pose.\n\n"
        methods += "### Ranking Criteria\n\n"
        methods += "Ligands were ranked in ascending order by binding affinity (ΔG in kcal/mol). "
        methods += "More negative values indicate stronger predicted binding."
        return methods

    def generate_results_section(self, analysis_results):
        """Generate results section with figures."""
        results = "## Results\n\n"
        
        ranked_ligands = analysis_results.get("ranked_ligands", [])
        
        if not ranked_ligands:
            results += "No valid docking results were obtained.\n"
            return results

        results += self.generate_executive_summary(ranked_ligands)
        results += "\n\n### Ligand Ranking\n\n"
        results += self._generate_ranking_table(ranked_ligands)
        
        interactions = analysis_results.get("interactions", {})
        if interactions:
            results += "\n\n### Interaction Analysis\n\n"
            results += self._generate_interaction_summary(interactions)
        
        return results

    def _generate_ranking_table(self, ranked_ligands):
        """Generate markdown table of ranked ligands."""
        table = "| Rank | Ligand Name | Binding Affinity (kcal/mol) | Pose ID | Total Poses |\n"
        table += "|------|-------------|------------------------------|---------|-------------|\n"
        
        for idx, ligand in enumerate(ranked_ligands, 1):
            table += f"| {idx} | {ligand['ligand_name']} | {ligand['binding_affinity']} | {ligand['pose_id']} | {ligand['total_poses']} |\n"
        
        return table

    def _generate_interaction_summary(self, interactions):
        """Generate interaction summary text."""
        if not interactions:
            return "Interaction analysis was not performed or no interactions were detected."
        
        summary = "Key molecular interactions were identified for the top-ranked ligands. "
        summary += "Detailed interaction profiles are available in the supplementary data."
        return summary

    def generate_discussion_section(self, analysis_results):
        """Generate discussion and interpretation section."""
        discussion = "## Discussion\n\n"
        
        ranked_ligands = analysis_results.get("ranked_ligands", [])
        
        if not ranked_ligands:
            discussion += "No ligands could be ranked due to insufficient or invalid docking data.\n"
            return discussion
        
        best = ranked_ligands[0]
        discussion += f"The top-ranked ligand, **{best['ligand_name']}**, exhibits the most favorable predicted binding affinity "
        discussion += f"({best['binding_affinity']} kcal/mol) among the tested compounds. "
        discussion += "This suggests a potentially strong interaction with the target protein.\n\n"
        
        if len(ranked_ligands) > 1:
            discussion += f"A total of {len(ranked_ligands)} ligands were successfully evaluated. "
            discussion += "The range of binding affinities provides insight into structure-activity relationships "
            discussion += "and may guide further optimization efforts.\n\n"
        
        discussion += "### Limitations\n\n"
        discussion += "These results are based on computational predictions and have inherent limitations:\n\n"
        discussion += "- Docking scores are estimates and may not reflect true binding affinities\n"
        discussion += "- Protein flexibility and solvent effects are approximated\n"
        discussion += "- Entropic contributions may not be fully captured\n"
        discussion += "- Experimental validation is required to confirm predictions\n"
        
        return discussion

    def add_scientific_disclaimer(self):
        """Add required scientific disclaimer to report."""
        disclaimer = "## Scientific Disclaimer\n\n"
        disclaimer += "**IMPORTANT:** This report presents computational predictions generated by molecular docking simulations. "
        disclaimer += "These results are intended for research purposes only and should not be interpreted as definitive evidence of biological activity, "
        disclaimer += "therapeutic efficacy, or safety.\n\n"
        disclaimer += "Key limitations:\n\n"
        disclaimer += "- Docking predictions require experimental validation through biochemical and cellular assays\n"
        disclaimer += "- Binding affinity predictions may not correlate with biological activity\n"
        disclaimer += "- No claims regarding drug efficacy, safety, or regulatory approval are made or implied\n"
        disclaimer += "- Results should be interpreted by qualified researchers with domain expertise\n"
        disclaimer += "- This analysis does not replace expert judgment or experimental validation\n\n"
        disclaimer += "Users are responsible for appropriate interpretation and application of these results within their research context."
        return disclaimer

    def export_to_pdf(self, report, output_path):
        """Export report to PDF format."""
        # Not implemented in this scope
        pass
